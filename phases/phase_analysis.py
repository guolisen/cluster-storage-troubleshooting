#!/usr/bin/env python3
"""
Phase 1: ReAct Investigation for Kubernetes Volume Troubleshooting

This module contains the implementation of Phase 1 (ReAct Investigation)
which actively investigates using tools with pre-collected data as base knowledge.
"""

import logging
import asyncio
from typing import Dict, List, Any, Optional, Tuple
from rich.console import Console
from rich.panel import Panel
from langgraph.graph import StateGraph

from troubleshooting.graph import create_troubleshooting_graph_with_context

logger = logging.getLogger(__name__)

class AnalysisPhase:
    """
    Implementation of Phase 1: ReAct Investigation
    
    This class handles the active investigation of volume I/O errors
    using the Investigation Plan and pre-collected data.
    """
    
    def __init__(self, collected_info: Dict[str, Any], config_data: Dict[str, Any]):
        """
        Initialize the Analysis Phase
        
        Args:
            collected_info: Pre-collected diagnostic information from Phase 0
            config_data: Configuration data for the system
        """
        self.collected_info = collected_info
        self.config_data = config_data
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.console = Console()
    
    async def run_analysis_with_graph(self, query: str, graph: StateGraph, timeout_seconds: int = 60) -> str:
        """
        Run an analysis using the provided LangGraph StateGraph with enhanced progress tracking
        
        Args:
            query: The initial query to send to the graph
            graph: LangGraph StateGraph to use
            timeout_seconds: Maximum execution time in seconds
            
        Returns:
            str: Analysis result
        """
        try:
            formatted_query = {"messages": [{"role": "user", "content": query}]}
            
            # First show the analysis panel
            self.console.print("\n")
            self.console.print(Panel(
                "[yellow]Starting analysis with LangGraph...\nThis may take a few minutes to complete.", 
                title="[bold blue]Analysis Phase",
                border_style="blue"
            ))
            
            # Run graph with timeout
            try:
                response = await asyncio.wait_for(
                    graph.ainvoke(formatted_query, config={"recursion_limit": 100}),
                    timeout=timeout_seconds
                )
                self.console.print("[green]Analysis complete![/green]")
            except asyncio.TimeoutError:
                self.console.print("[red]Analysis timed out![/red]")
                raise
            except Exception as e:
                self.console.print(f"[red]Analysis failed: {str(e)}[/red]")
                raise
            
            # Extract analysis results
            if response["messages"]:
                if isinstance(response["messages"], list):
                    final_message = response["messages"][-1].content
                else:
                    final_message = response["messages"].content
            else:
                final_message = "Failed to generate analysis results"
            
            return final_message
        except Exception as e:
            self.logger.error(f"Error in run_analysis_with_graph: {str(e)}")
            return f"Error in analysis: {str(e)}"
    
    async def run_investigation(self, pod_name: str, namespace: str, volume_path: str, 
                               investigation_plan: str) -> str:
        """
        Run the investigation based on the Investigation Plan
        
        Args:
            pod_name: Name of the pod with the error
            namespace: Namespace of the pod
            volume_path: Path of the volume with I/O error
            investigation_plan: Investigation Plan generated by the Plan Phase
            
        Returns:
            str: Analysis result
        """
        try:
            # Create troubleshooting graph with pre-collected context
            graph = create_troubleshooting_graph_with_context(
                self.collected_info, phase="phase1", config_data=self.config_data
            )
            
            # Updated query for ReAct investigation phase with Investigation Plan
            query = f"""Phase 1 - ReAct Investigation: Execute the Investigation Plan to actively investigate the volume I/O error in pod {pod_name} in namespace {namespace} at volume path {volume_path}.

You have:
1. Pre-collected diagnostic information from Phase 0 as base knowledge
2. A structured Investigation Plan generated by the Plan Phase

INVESTIGATION PLAN TO FOLLOW:
{investigation_plan}

Your task is to:
1. Parse the Investigation Plan and execute each step sequentially
2. Use the specified Knowledge Graph tools first (as outlined in the plan)
3. Validate expected outcomes against actual results from each step
4. If a step fails or provides unexpected results, use the fallback steps provided
5. Use additional ReAct tools for comprehensive root cause analysis and verification
6. Aggregate results from all Investigation Plan steps
7. Generate a comprehensive root cause analysis and fix plan

EXECUTION GUIDELINES:
- Follow the Investigation Plan steps in order
- For each step, use the specified tool with the given arguments
- Compare actual results with expected outcomes
- Log execution details for traceability
- If Knowledge Graph queries provide insufficient data, supplement with additional diagnostic tools
- Include evidence from both the Investigation Plan execution and additional tool usage

INVESTIGATION PLAN EXECUTION LOG:
Execute each step from the Investigation Plan and document:
- Step number and description
- Tool used and arguments
- Actual outcome vs expected outcome
- Any issues or unexpected results
- Follow-up actions taken

After completing the Investigation Plan, provide comprehensive root cause analysis and fix plan.

<<< Note >>>: Please provide the root cause and fix plan analysis within 30 tool calls.
"""
            # Set timeout
            timeout_seconds = self.config_data['troubleshoot']['timeout_seconds']
            
            # Run analysis using the tools module
            phase1_response = await self.run_analysis_with_graph(
                query=query,
                graph=graph,
                timeout_seconds=timeout_seconds
            )
            
            return phase1_response

        except Exception as e:
            error_msg = f"Error during analysis phase: {str(e)}"
            self.logger.error(error_msg)
            return error_msg


async def run_analysis_phase_with_plan(pod_name: str, namespace: str, volume_path: str, 
                                     collected_info: Dict[str, Any], investigation_plan: str,
                                     config_data: Dict[str, Any]) -> str:
    """
    Run Phase 1: ReAct Investigation with pre-collected information as base knowledge
    
    Args:
        pod_name: Name of the pod with the error
        namespace: Namespace of the pod
        volume_path: Path of the volume with I/O error
        collected_info: Pre-collected diagnostic information from Phase 0
        investigation_plan: Investigation Plan generated by the Plan Phase
        config_data: Configuration data
        
    Returns:
        str: Analysis result
    """
    logging.info("Starting Phase 1: ReAct Investigation with Plan")
    
    console = Console()
    console.print("\n")
    console.print(Panel(
        "[bold white]Executing Investigation Plan to actively investigate volume I/O issue...",
        title="[bold magenta]PHASE 1: REACT INVESTIGATION WITH PLAN",
        border_style="magenta",
        padding=(1, 2)
    ))
    
    try:
        # Initialize the analysis phase
        phase = AnalysisPhase(collected_info, config_data)
        
        # Run the investigation
        result = await phase.run_investigation(pod_name, namespace, volume_path, investigation_plan)
        
        return result
    
    except Exception as e:
        error_msg = f"Error during analysis phase: {str(e)}"
        logging.error(error_msg)
        return error_msg
