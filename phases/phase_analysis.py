#!/usr/bin/env python3
"""
Phase 1: ReAct Investigation for Kubernetes Volume Troubleshooting

This module contains the implementation of Phase 1 (ReAct Investigation)
which actively investigates using tools with pre-collected data as base knowledge.
"""

import logging
import asyncio
from typing import Dict, List, Any, Optional, Tuple
from rich.console import Console
from rich.panel import Panel
from langgraph.graph import StateGraph

from troubleshooting.graph import create_troubleshooting_graph_with_context
from troubleshooting.utils import (
    HistoricalExperienceFormatter,
    GraphExecutor,
    ErrorHandler,
    MessageListManager,
    OutputFormatter
)

logger = logging.getLogger(__name__)


class AnalysisPhase:
    """
    Implementation of Phase 1: ReAct Investigation
    
    This class handles the active investigation of volume I/O errors
    using the Investigation Plan and pre-collected data. It creates a
    LangGraph ReAct workflow that executes the Investigation Plan and
    generates a comprehensive analysis with root cause and fix plan.
    """
    
    def __init__(self, collected_info: Dict[str, Any], config_data: Dict[str, Any]):
        """
        Initialize the Analysis Phase
        
        Args:
            collected_info: Pre-collected diagnostic information from Phase 0
            config_data: Configuration data for the system
        """
        self.collected_info = collected_info
        self.config_data = config_data
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.console = Console()
    
    async def run_investigation(self, pod_name: str, namespace: str, volume_path: str, 
                               investigation_plan: str, message_list: List[Dict[str, str]] = None) -> Tuple[str, List[Dict[str, str]]]:
        """
        Run the investigation based on the Investigation Plan
        
        Args:
            pod_name: Name of the pod with the error
            namespace: Namespace of the pod
            volume_path: Path of the volume with I/O error
            investigation_plan: Investigation Plan generated by the Plan Phase
            message_list: Optional message list for chat mode
            
        Returns:
            Tuple[str, List[Dict[str, str]]]: (Analysis result, Updated message list)
        """
        try:
            # Initialize message list if not provided
            message_list = self._initialize_message_list(message_list)
            
            # Create troubleshooting graph with pre-collected context
            graph = self._create_troubleshooting_graph()
            
            # Prepare query for the graph
            query = self._prepare_investigation_query(
                pod_name, namespace, volume_path, investigation_plan
            )
            
            # Add investigation plan to message list if not already present
            message_list = self._add_investigation_plan_to_messages(
                message_list, query
            )
            
            # Execute graph and get final response
            final_message, message_list = await self._execute_graph_and_get_response(
                graph, message_list
            )
            
            return final_message, message_list

        except Exception as exception:
            return self._handle_investigation_error(exception, message_list)
    
    def _initialize_message_list(self, message_list: Optional[List[Dict[str, str]]]) -> List[Dict[str, str]]:
        """
        Initialize message list with system prompt if not provided
        
        Args:
            message_list: Optional existing message list
            
        Returns:
            List[Dict[str, str]]: Initialized message list
        """
        if message_list is None:
            system_prompt = self._create_system_prompt()
            return [{"role": "system", "content": system_prompt}]
        
        return message_list
    
    def _create_system_prompt(self) -> str:
        """
        Create the system prompt for Phase 1
        
        Returns:
            str: System prompt for Phase 1
        """
        return """You are an expert Kubernetes storage troubleshooter. Your task is to investigate volume I/O errors in Kubernetes pods and generate a comprehensive Fix Plan.

TASK:
1. Execute the Investigation Plan to identify the root cause of volume I/O errors
2. Analyze the results of the investigation
3. Generate a comprehensive Fix Plan to resolve the identified issues

CONSTRAINTS:
- Follow the Investigation Plan step by step
- Use only the tools available in the Phase1 tool registry
- Provide a detailed root cause analysis
- Generate a clear, actionable Fix Plan

OUTPUT FORMAT:
Your response must include:
1. Summary of Findings
2. Detailed Analysis
3. Root Cause
4. Fix Plan
"""
    
    def _create_troubleshooting_graph(self) -> StateGraph:
        """
        Create the troubleshooting graph with pre-collected context
        
        Returns:
            StateGraph: LangGraph StateGraph for troubleshooting
        """
        return create_troubleshooting_graph_with_context(
            self.collected_info, phase="phase1", config_data=self.config_data
        )
    
    def _prepare_investigation_query(self, pod_name: str, namespace: str, 
                                   volume_path: str, investigation_plan: str) -> str:
        """
        Prepare the investigation query for the graph
        
        Args:
            pod_name: Name of the pod with the error
            namespace: Namespace of the pod
            volume_path: Path of the volume with I/O error
            investigation_plan: Investigation Plan to follow
            
        Returns:
            str: Formatted investigation query
        """
        # Extract and format historical experience data
        historical_experiences_formatted = self._format_historical_experiences()
        
        # Create special case detection instructions
        special_case_instructions = self._create_special_case_instructions()
        
        # Create query with dynamic data for LangGraph workflow
        return f"""Phase 1 - ReAct Investigation: Execute the Investigation Plan to actively investigate the volume I/O error in pod {pod_name} in namespace {namespace} at volume path {volume_path}.

INVESTIGATION PLAN TO FOLLOW:
{investigation_plan}

HISTORICAL EXPERIENCE:
{historical_experiences_formatted}

SPECIAL CASE DETECTION:
{special_case_instructions}

<<< Note >>>: Please provide the root cause and fix plan analysis within 30 tool calls.
"""
    
    def _format_historical_experiences(self) -> str:
        """
        Format historical experience data from collected_info
        
        Returns:
            str: Formatted historical experience data
        """
        return HistoricalExperienceFormatter.format_historical_experiences(
            self.collected_info
        )
    
    def _create_special_case_instructions(self) -> str:
        """
        Create instructions for special case detection
        
        Returns:
            str: Special case detection instructions
        """
        return """After executing the Investigation Plan, you must determine if one of these special cases applies:

CASE 1 - NO ISSUES DETECTED:
If the Knowledge Graph and Investigation Plan execution confirm the system has no issues:
- Output a structured summary in the following format:
  ```
  Summary Finding: No issues detected in the system.
  Evidence: [Details from Knowledge Graph queries, e.g., no error logs found, all services operational]
  Advice: [Recommendations, e.g., continue monitoring the system]
  SKIP_PHASE2: YES
  ```

CASE 2 - MANUAL INTERVENTION REQUIRED:
If the Knowledge Graph and Investigation Plan execution confirm the issue cannot be fixed automatically:
- Output a structured summary in the following format:
  ```
  Summary Finding: Issue detected, but requires manual intervention.
  Evidence: [Details from Knowledge Graph queries, e.g., specific error or configuration requiring human action]
  Advice: [Detailed step-by-step instructions for manual resolution, e.g., specific commands or actions for the user]
  SKIP_PHASE2: YES
  ```

CASE 3 - AUTOMATIC FIX POSSIBLE:
If the issue can be resolved automatically:
- Generate a fix plan based on the Investigation Plan's results
- Output a comprehensive root cause analysis and fix plan
- Do NOT include the SKIP_PHASE2 marker"""
    
    def _add_investigation_plan_to_messages(self, message_list: List[Dict[str, str]], 
                                          investigation_plan: str) -> List[Dict[str, str]]:
        """
        Add investigation plan to message list if not already present
        
        Args:
            message_list: Existing message list
            investigation_plan: Investigation Plan to add
            
        Returns:
            List[Dict[str, str]]: Updated message list
        """
        # Only add if message list only contains system prompt
        if len(message_list) == 1:  # Only system prompt exists
            return MessageListManager.add_to_message_list(
                message_list, 
                f"{investigation_plan}",
                "user"
            )
        
        return message_list
    
    async def _execute_graph_and_get_response(self, graph: StateGraph, 
                                            message_list: List[Dict[str, str]]) -> Tuple[str, List[Dict[str, str]]]:
        """
        Execute the graph and get the final response
        
        Args:
            graph: LangGraph StateGraph to execute
            message_list: Message list for the graph
            
        Returns:
            Tuple[str, List[Dict[str, str]]]: (Final response, Updated message list)
        """
        # Set timeout from config
        timeout_seconds = self.config_data.get('troubleshoot', {}).get('timeout_seconds', 600)
        
        # Create initial state with messages
        initial_state = {"messages": message_list}
        
        # Execute graph
        final_state = await GraphExecutor.execute_graph(
            graph, initial_state, timeout_seconds
        )
        
        # Extract final response
        final_message = GraphExecutor.extract_final_response(final_state)
        
        # Add final response to message list
        message_list = MessageListManager.add_to_message_list(message_list, final_message)
        
        return final_message, message_list
    
    def _handle_investigation_error(self, exception: Exception, 
                                  message_list: List[Dict[str, str]]) -> Tuple[str, List[Dict[str, str]]]:
        """
        Handle errors during investigation
        
        Args:
            exception: Exception that occurred
            message_list: Message list to update
            
        Returns:
            Tuple[str, List[Dict[str, str]]]: (Error message, Updated message list)
        """
        error_msg = ErrorHandler.create_error_response(
            exception, "Error during analysis phase"
        )
        
        # Add error message to message list
        if message_list is not None:
            message_list = MessageListManager.add_to_message_list(message_list, error_msg)
        
        self.logger.error(f"Error in analysis phase: {str(exception)}")
        return error_msg, message_list


async def run_analysis_phase_with_plan(pod_name: str, namespace: str, volume_path: str, 
                                     collected_info: Dict[str, Any], investigation_plan: str,
                                     config_data: Dict[str, Any], message_list: List[Dict[str, str]] = None) -> Tuple[str, bool, List[Dict[str, str]]]:
    """
    Run Phase 1: ReAct Investigation with pre-collected information as base knowledge
    
    Args:
        pod_name: Name of the pod with the error
        namespace: Namespace of the pod
        volume_path: Path of the volume with I/O error
        collected_info: Pre-collected diagnostic information from Phase 0
        investigation_plan: Investigation Plan generated by the Plan Phase
        config_data: Configuration data
        message_list: Optional message list for chat mode
        
    Returns:
        Tuple[str, bool, List[Dict[str, str]]]: (Analysis result, Skip Phase2 flag, Updated message list)
    """
    logging.info("Starting Phase 1: ReAct Investigation with Plan")
    
    # Display phase header
    _display_phase_header()
    
    try:
        # Initialize the analysis phase
        phase = AnalysisPhase(collected_info, config_data)
        
        # Run the investigation
        result, message_list = await phase.run_investigation(
            pod_name, namespace, volume_path, investigation_plan, message_list
        )
        
        # Process the result
        return _process_analysis_result(result, message_list)
    
    except Exception as exception:
        return _handle_phase_error(exception, message_list)


def _display_phase_header() -> None:
    """
    Display the phase header in the console
    """
    console = Console()
    console.print("\n")
    console.print(Panel(
        "[bold white]Executing Investigation Plan to actively investigate volume I/O issue...",
        title="[bold magenta]PHASE 1: REACT INVESTIGATION WITH PLAN",
        border_style="magenta",
        padding=(1, 2)
    ))


def _process_analysis_result(result: str, message_list: List[Dict[str, str]]) -> Tuple[str, bool, List[Dict[str, str]]]:
    """
    Process the analysis result to determine if Phase 2 should be skipped
    
    Args:
        result: Analysis result
        message_list: Message list
        
    Returns:
        Tuple[str, bool, List[Dict[str, str]]]: (Processed result, Skip Phase2 flag, Message list)
    """
    # Check if the result contains the SKIP_PHASE2 marker
    skip_phase2 = "SKIP_PHASE2: YES" in result
    
    # Remove the SKIP_PHASE2 marker from the output if present
    if skip_phase2:
        result = result.replace("SKIP_PHASE2: YES", "").strip()
        logging.info("Phase 1 indicated Phase 2 should be skipped")
    
    # Check if Phase 2 should be skipped based on the content of the result
    if not skip_phase2:
        skip_phase2 = GraphExecutor.should_skip_phase2(result)
    
    return result, skip_phase2, message_list


def _handle_phase_error(exception: Exception, message_list: List[Dict[str, str]]) -> Tuple[str, bool, List[Dict[str, str]]]:
    """
    Handle errors during the analysis phase
    
    Args:
        exception: Exception that occurred
        message_list: Message list to update
        
    Returns:
        Tuple[str, bool, List[Dict[str, str]]]: (Error message, Skip Phase2 flag, Updated message list)
    """
    error_msg = ErrorHandler.create_error_response(
        exception, "Error during analysis phase"
    )
    
    # Add error message to message list
    if message_list is not None:
        message_list = MessageListManager.add_to_message_list(message_list, error_msg)
    
    logging.error(f"Error in analysis phase: {str(exception)}")
    return error_msg, False, message_list
