#!/usr/bin/env python3
"""
Phase 1: ReAct Investigation for Kubernetes Volume Troubleshooting

This module contains the implementation of Phase 1 (ReAct Investigation)
which actively investigates using tools with pre-collected data as base knowledge.
"""

import logging
import asyncio
from typing import Dict, List, Any, Optional, Tuple
from rich.console import Console
from rich.panel import Panel
from langgraph.graph import StateGraph

from troubleshooting.graph import create_troubleshooting_graph_with_context

logger = logging.getLogger(__name__)

class AnalysisPhase:
    """
    Implementation of Phase 1: ReAct Investigation
    
    This class handles the active investigation of volume I/O errors
    using the Investigation Plan and pre-collected data.
    """
    
    def __init__(self, collected_info: Dict[str, Any], config_data: Dict[str, Any]):
        """
        Initialize the Analysis Phase
        
        Args:
            collected_info: Pre-collected diagnostic information from Phase 0
            config_data: Configuration data for the system
        """
        self.collected_info = collected_info
        self.config_data = config_data
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.console = Console()
    
    async def run_analysis_with_graph(self, query: str, graph: StateGraph, timeout_seconds: int = 60) -> str:
        """
        Run an analysis using the provided LangGraph StateGraph with enhanced progress tracking
        
        Args:
            query: The initial query to send to the graph
            graph: LangGraph StateGraph to use
            timeout_seconds: Maximum execution time in seconds
            
        Returns:
            str: Analysis result
        """
        try:
            formatted_query = {"messages": [{"role": "user", "content": query}]}
            
            # First show the analysis panel
            self.console.print("\n")
            self.console.print(Panel(
                "[yellow]Starting analysis with LangGraph...\nThis may take a few minutes to complete.", 
                title="[bold blue]Analysis Phase",
                border_style="blue"
            ))
            
            # Run graph with timeout
            try:
                response = await asyncio.wait_for(
                    graph.ainvoke(formatted_query, config={"recursion_limit": 100}),
                    timeout=timeout_seconds
                )
                self.console.print("[green]Analysis complete![/green]")
            except asyncio.TimeoutError:
                self.console.print("[red]Analysis timed out![/red]")
                raise
            except Exception as e:
                self.console.print(f"[red]Analysis failed: {str(e)}[/red]")
                raise
            
            # Extract analysis results
            if response["messages"]:
                if isinstance(response["messages"], list):
                    final_message = response["messages"][-1].content
                else:
                    final_message = response["messages"].content
            else:
                final_message = "Failed to generate analysis results"
            
            return final_message
        except Exception as e:
            self.logger.error(f"Error in run_analysis_with_graph: {str(e)}")
            return f"Error in analysis: {str(e)}"
    
    async def run_investigation(self, pod_name: str, namespace: str, volume_path: str, 
                               investigation_plan: str) -> str:
        """
        Run the investigation based on the Investigation Plan
        
        Args:
            pod_name: Name of the pod with the error
            namespace: Namespace of the pod
            volume_path: Path of the volume with I/O error
            investigation_plan: Investigation Plan generated by the Plan Phase
            
        Returns:
            str: Analysis result
        """
        try:
            # Create troubleshooting graph with pre-collected context
            graph = create_troubleshooting_graph_with_context(
                self.collected_info, phase="phase1", config_data=self.config_data
            )
            
            # Updated query for ReAct investigation phase with Investigation Plan
            query = f"""Phase 1 - ReAct Investigation: Execute the Investigation Plan to actively investigate the volume I/O error in pod {pod_name} in namespace {namespace} at volume path {volume_path}.

You have:
1. Pre-collected diagnostic information from Phase 0 as base knowledge
2. A structured Investigation Plan generated by the Plan Phase
3. Historical experience data from previous volume I/O failures

INVESTIGATION PLAN TO FOLLOW:
{investigation_plan}

USING HISTORICAL EXPERIENCE:
The Knowledge Graph contains historical experience data with previous cases of volume I/O failures. 
For each relevant historical experience entry, consider:
- The phenomenon description to identify patterns similar to the current issue
- The root cause to help narrow down your investigation and identify the underlying cause
- The localization method to guide which tools to use for diagnostic steps
- The resolution method to develop an effective fix plan

When you're executing steps from the Investigation Plan, pay attention to steps that were specifically informed by historical experience. These steps may be more likely to identify the root cause if the current issue matches a previously observed pattern.

Your task is to:
1. Parse the Investigation Plan and execute each step sequentially
2. Use the specified Knowledge Graph tools first (as outlined in the plan)
3. Validate expected outcomes against actual results from each step
4. If a step fails or provides unexpected results, use the fallback steps provided
5. Use additional ReAct tools for comprehensive root cause analysis and verification
6. Aggregate results from all Investigation Plan steps
7. Generate a comprehensive root cause analysis that references relevant historical experiences

SPECIAL CASE DETECTION:
After executing the Investigation Plan, you must determine if one of these special cases applies:

CASE 1 - NO ISSUES DETECTED:
If the Knowledge Graph and Investigation Plan execution confirm the system has no issues:
- Output a structured summary in the following format:
  ```
  Summary Finding: No issues detected in the system.
  Evidence: [Details from Knowledge Graph queries, e.g., no error logs found, all services operational]
  Advice: [Recommendations, e.g., continue monitoring the system]
  SKIP_PHASE2: YES
  ```

CASE 2 - MANUAL INTERVENTION REQUIRED:
If the Knowledge Graph and Investigation Plan execution confirm the issue cannot be fixed automatically:
- Output a structured summary in the following format:
  ```
  Summary Finding: Issue detected, but requires manual intervention.
  Evidence: [Details from Knowledge Graph queries, e.g., specific error or configuration requiring human action]
  Advice: [Detailed step-by-step instructions for manual resolution, e.g., specific commands or actions for the user]
  SKIP_PHASE2: YES
  ```

CASE 3 - AUTOMATIC FIX POSSIBLE:
If the issue can be resolved automatically:
- Generate a fix plan based on the Investigation Plan's results
- Output a comprehensive root cause analysis and fix plan
- Do NOT include the SKIP_PHASE2 marker

<<< Note >>>: Please provide the root cause and fix plan analysis within 30 tool calls.
"""
            # Set timeout
            timeout_seconds = self.config_data['troubleshoot']['timeout_seconds']
            
            # Run analysis using the tools module
            phase1_response = await self.run_analysis_with_graph(
                query=query,
                graph=graph,
                timeout_seconds=timeout_seconds
            )
            
            return phase1_response

        except Exception as e:
            error_msg = f"Error during analysis phase: {str(e)}"
            self.logger.error(error_msg)
            return error_msg


async def run_analysis_phase_with_plan(pod_name: str, namespace: str, volume_path: str, 
                                     collected_info: Dict[str, Any], investigation_plan: str,
                                     config_data: Dict[str, Any]) -> Tuple[str, bool]:
    """
    Run Phase 1: ReAct Investigation with pre-collected information as base knowledge
    
    Args:
        pod_name: Name of the pod with the error
        namespace: Namespace of the pod
        volume_path: Path of the volume with I/O error
        collected_info: Pre-collected diagnostic information from Phase 0
        investigation_plan: Investigation Plan generated by the Plan Phase
        config_data: Configuration data
        
    Returns:
        Tuple[str, bool]: (Analysis result, Skip Phase2 flag)
    """
    logging.info("Starting Phase 1: ReAct Investigation with Plan")
    
    console = Console()
    console.print("\n")
    console.print(Panel(
        "[bold white]Executing Investigation Plan to actively investigate volume I/O issue...",
        title="[bold magenta]PHASE 1: REACT INVESTIGATION WITH PLAN",
        border_style="magenta",
        padding=(1, 2)
    ))
    
    try:
        # Initialize the analysis phase
        phase = AnalysisPhase(collected_info, config_data)
        
        # Run the investigation
        result = await phase.run_investigation(pod_name, namespace, volume_path, investigation_plan)
        
        # Check if the result contains the SKIP_PHASE2 marker
        skip_phase2 = "SKIP_PHASE2: YES" in result
        
        # Remove the SKIP_PHASE2 marker from the output if present
        if skip_phase2:
            result = result.replace("SKIP_PHASE2: YES", "").strip()
            logging.info("Phase 1 indicated Phase 2 should be skipped")
        
        return result, skip_phase2
    
    except Exception as e:
        error_msg = f"Error during analysis phase: {str(e)}"
        logging.error(error_msg)
        return error_msg, False
